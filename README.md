# wsb_repository
我个人的一些练手项目
项目
===================================
帖子：int userid, String title, String content, int ID ,String title, int status , Date date, int commentcount
评论：int id, int Userid, String content, Date date, int entityType(评论目标的类型，帖子||评论)
消息：int id, int fromId, int toId, String conversationId, String content, Data createTime



计算机网络
===========================================================
TCP的拥塞控制（作用于网络）：
１、慢开始避免拥塞
２、快重传（发送方连续收到三个一样的确认包，就会重传）
3、快恢复：发送方连续收到三个确认后，门限减半，不执行满开始算法，将窗口设置为门限减半后的值，执行拥塞避免算法，使接受窗口缓慢变大。
流量控制作用于接收者：
流量控制怎么引起的死锁：发送者收到了一个窗口为0的应答，便等待下一个应答，此时接收者以为发送者已经收到该应答，等待接收新数据，这样双方就互相等待，产生死锁；
使用计时器解决这个问题。


Mysql
===================================================================================================================================
redo日志是InnoDB独有的，它让Mysql拥有了崩溃恢复的能力；
为什么不是直接对数据也进行
主键索引---叶子结点存储的都是整条记录
非主键索引：叶子结点存储的主键ID，
回表：基于非主键索引的查询，需要多扫描一颗索引树，通过索引拿到数据行id，





操作系统
==================================================================================================================================
线程间的通信方式：
线程间的通信主要是为了同步，所以没有进程通信中进行数据交换的通信机制
1、锁机制：包括互斥锁、条件变量、读写锁
2、信号量机制(Semaphore)
3、信号机制
######内存泄漏和内存溢出
内存泄漏：向系统申请分配内存进行使用，使用完了没有GC，内存泄漏不会抛异常，内存溢出会抛异常；
##########＜PCB块＞
OS将内存中的多个PCB块组织成链表或队列
#####PCB主要包括一下信息：
进程标识符<唯一标识进程>
处理机的状态；
进程的调度信息<进程状态 + 进程优先级 + 进程调度所需的其他信息+ 事件即阻塞原因>
进程的控制信息：<数据和程序的地址+进程的同步和通信机制+资源清单+链接地址>
#####PCB的组织方式
链接方式：－＞把具有同一状态的PCB链接成一个队列《准备，就绪，阻塞等》
索引方式：－＞
进程的创建步骤-> 
申请PCB； 为新进程分配资源； 初始化PCB块；将新进程插入就绪队列
进程的同步---->>>>>
临界区： 人们把在进程中访问临界资源（打印机，磁带机等）的那段代码成为临界区，若能保证各进程互斥地进入自己的临界区，便可实现进程对临界区的互斥访问；

#####
select/poll基于轮询机制，select一般有连接限制，poll基于链表没有连接限制，要把fd集合从用户态拷贝到内核态，耗费性能
epoll的优点： 利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。
/////select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。 - 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 - 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 - 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。
epoll基于IO事件通知机制，分为水平触发和边缘触发，
水平: 只要fd有读写事件，epoll机会通知
边缘：只通知一次，


＃JVM和JMM
==================================================================================================================================
JMM：主内存+每个线程对应的工作内存
处理器重排序和缓存一致性指令；
处理器使用写缓冲区与内存进行交互，可能会导致指令实际执行顺序与本来的顺序不一致；
#######
在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurrent包等解决原子性、有序性和可见性三大问题。

###########有序性指的是程序要按照代码的先后顺序执行，编译器为了优化性能，有时候会改变程序中语句的先后顺序
使用synchronized和volatile来保证多线程之间操作的有序性，volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。
使用volatile关键字的场景：
1、 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2、该变量没有包含在具有其他变量的不变式中。

#####类加载过程
类的加载需要类加载器，《加载器》有四类：启动类加载器，标准扩展类加载器，应用类加载器，用户自定义类加载器；
如何打破双亲委派机制：自定义类加载器，重写loadclass()方法，

///为什么tomcat需要打破双亲委派机制？
web容器可能部署多个应用，每个应用依赖的jar包路径相同但是版本不同，采用双亲委派无法加载多个相同的累，所以采用隔离机制，为每个web容器单独提供一个WebAppClassLoader


第一步加载：通过类的全限定名（包名+类名）获取该类的.class文件的二进制字节流，加载到内存
映射成jvm能识别的结构->在内存中生成class文件。
第二步链接：
1、验证->
2、准备->为类中的静态变量分配内存，并设置默认的初始值，比如int类型初始值为0，被final修饰的static字段不会设置，编译的时候就被分配了
3、解析->将常量池的中的符号引用转换成直接引用的过程
#####################＜JVM模型＞
堆，本地方法栈，虚拟机栈（线程私有，存储局部变量表，操作栈，动态链接，方法出口），方法区（线程共享，存储类的信息，常量，静态变量，即时编译器编译后的代码），程序计数器

#垃圾回收算法
=======================================================================
首先判断哪些是垃圾？
1、引用计数算法
2、可达性分析
垃圾回收算法
1、标记-清除
2、标记-复制
3、标记-整理
垃圾回收器
CMS、G１


#反射
================================
随时可以动态地获得类的对象和属性，
获取Class对象，有四种方法：
1、Class.forName("类的路径")
2、类名.class
3、对象名.getClass()
4、基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象




数据库
====================================================================================================================================
事务的特性：原子性，一致性，隔离性，持久性
事务隔离级别：读未提交，读已提交，重复读，序列化(脏读，重复读，幻读)
MYSQL怎么在可重复读的条件下解决了幻读的问题，是通过行锁和间隙锁的组合Next-Key实现的。
https://zhuanlan.zhihu.com/p/27790194


算法与数据结构
========================================================================================================================================
二叉树的最近公共祖先；
二叉树的非递归遍历；
最长的递增子序列；



