# wsb_repository
我个人的一些练手项目
# 项目
帖子：int userid, String title, String content, int ID ,String title, int status , Date date, int commentcount
评论：int id, int Userid, String content, Date date, int entityType(评论目标的类型，帖子||评论)
消息：int id, int fromId, int toId, String conversationId, String content, Data createTime

### spring IOC?
IOC翻译过来的意思是控制反转，也被称作为依赖注入。通过将主动创建对象过程变成了被动接收，编译期依赖变成了运行时依赖，以此来降低对象之间的耦合度。
为了实现依赖注入，需要在XML内配置好依赖关系，并且将对象实例化，销毁，等过程统一交由IOC容器进行管理。这样的话，由于IOC容器将类的实例化过程透明化，
并且创建的是单例对象，所以在方便调用方的使用同时，还减少了内存的占用。  
Spring怎么解决依赖的？　先构建对象实例，再注入属性。　有两个池子，一个成品池，一个半成品池。  
spring获取Bean有几种方式？ApplicationContext+ContextLoader+通过spring提供的utils类获取ApplicationContext对象。

### Spring中的AOP怎么回答?
面向对象编程(OOP) 引入封装、继承、多态等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们要为分散的对象引入公共的行为
时，OOP显得无能为力。OOP允许定义由上到下的关系，但是从左到右的关系不适合定义。
AOP技术就是将影响多个类的公共行为封装到一个可重用模块，将其命名为切面。可以降低代码的重复率，减小耦合度，有利于未来的可操作性和
可维护性。
实现AOP技术主要分为两大类：采用动态代理技术，利用拦截方法的方式，对该方法进行装饰，以取代原有对象行为的执行；
二是采用静态织入的方式，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码。
### 静态代理：代理类在编译阶段生成吗，程序运行前就已经存在


### 动态代理：代理类运行时创建，代理类不是在Java代码中定义的，而是在运行时根据我们在Java代码中"指示"动态中生成的

JDK动态代理：定义一个功能接口，让代理类和被代理类实现这个接口。
1、拿到被代理类的接口列表；  
2、确定代理类的名字；  
3、根据接口信息，代码中动态创建代理类的字节码；  
4、将字节码转换成对应的class对象；  
5、创建InvocationHandler实例的handler,用来处理proxy所有的方法调用；  
6、Proxy的class对象以创建的handler对象魏参数，实例化一个Proxy对象。  
CGLIB动态代理： 代理类继承被代理类。  


### 怎么解决循环依赖问题?
初始化的时候需要装配属性问题，通过setter解决，



# 计算机网络
### TCP的拥塞控制（作用于网络）：
１、慢开始避免拥塞  
２、快重传（发送方连续收到三个一样的确认包，就会重传）  
3、快恢复：发送方连续收到三个确认后，门限减半，不执行满开始算法，将窗口设置为门限减半后的值，执行拥塞避免算法，使接受窗口缓慢变大。  
流量控制作用于接收者：
流量控制怎么引起的死锁：发送者收到了一个窗口为0的应答，便等待下一个应答，此时接收者以为发送者已经收到该应答，等待接收新数据，这样双方就互相等待，产生死锁；
使用计时器解决这个问题。
## 为什么说TCP是面向字节流的
应用层数据写入TCP的缓冲区中，发送的状态是按照字节流的方式发送的，跟应用层下来的报文长度没有任何的关系，
而对于UDP没有缓冲区，直接给报文加上包头就交给网络层。
## 四次挥手主动断开的一方为什么要有TIME_WAIT状态
防止被动断开的一方没有收到ACK确认，重传FIN包。

# 操作系统
线程间的通信方式：
线程间的通信主要是为了同步，所以没有进程通信中进行数据交换的通信机制  
1、锁机制：包括互斥锁、条件变量、读写锁  
2、信号量机制(Semaphore)  
3、信号机制  
### 内存泄漏和内存溢出
内存泄漏：向系统申请分配内存进行使用，使用完了没有GC，内存泄漏不会抛异常，内存溢出会抛异常；
### ＜PCB块＞
OS将内存中的多个PCB块组织成链表或队列
### PCB主要包括一下信息：
进程标识符<唯一标识进程>
处理机的状态；  
进程的调度信息<进程状态 + 进程优先级 + 进程调度所需的其他信息+ 事件即阻塞原因>  
进程的控制信息：<数据和程序的地址+进程的同步和通信机制+资源清单+链接地址>  
### PCB的组织方式
链接方式：－＞把具有同一状态的PCB链接成一个队列《准备，就绪，阻塞等》
索引方式：－＞
进程的创建步骤-> 
申请PCB； 为新进程分配资源； 初始化PCB块；将新进程插入就绪队列
进程的同步---->>>>>
临界区： 人们把在进程中访问临界资源（打印机，磁带机等）的那段代码成为临界区，若能保证各进程互斥地进入自己的临界区，便可实现进程对临界区的互斥访问；

### select/poll基于轮询机制，select一般有连接限制，poll基于链表没有连接限制，要把fd集合从用户态拷贝到内核态，耗费性能
epoll的优点： 利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。
/////select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，
epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；
epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。 
- 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），
会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
 - 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 - 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。
epoll基于IO事件通知机制，分为水平触发和边缘触发，
水平: 只要fd有读写事件，epoll机会通知
边缘：只通知一次，


# JVM和JMM
JMM：主内存+每个线程对应的工作内存
处理器重排序和缓存一致性指令；
处理器使用写缓冲区与内存进行交互，可能会导致指令实际执行顺序与本来的顺序不一致；
###
在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurrent包等解决原子性、有序性和可见性三大问题。

### 有序性指的是程序要按照代码的先后顺序执行，编译器为了优化性能，有时候会改变程序中语句的先后顺序
使用synchronized和volatile来保证多线程之间操作的有序性，volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。
使用volatile关键字的场景：
1、 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2、该变量没有包含在具有其他变量的不变式中。

### 类加载过程
类的加载需要类加载器，《加载器》有四类：启动类加载器，标准扩展类加载器，应用类加载器，用户自定义类加载器；
如何打破双亲委派机制：自定义类加载器，重写loadclass()方法，

///为什么tomcat需要打破双亲委派机制？
web容器可能部署多个应用，每个应用依赖的jar包路径相同但是版本不同，采用双亲委派无法加载多个相同的累，所以采用隔离机制，为每个web容器单独提供一个WebAppClassLoader


第一步加载：通过类的全限定名（包名+类名）获取该类的.class文件的二进制字节流，加载到内存
映射成jvm能识别的结构->在内存中生成class文件。
第二步链接：
1、验证->
2、准备->为类中的静态变量分配内存，并设置默认的初始值，比如int类型初始值为0，被final修饰的static字段不会设置，编译的时候就被分配了
3、解析->将常量池的中的符号引用转换成直接引用的过程
### ＜JVM模型＞
堆，本地方法栈，虚拟机栈（线程私有，存储局部变量表，操作栈，动态链接，方法出口），方法区（线程共享，存储类的信息，常量，静态变量，即时编译器编译后的代码），程序计数器

## 垃圾回收算法
＊首先判断哪些是垃圾？  
1、引用计数算法  
2、可达性分析  
＊垃圾回收算法  
1、标记-清除  
2、标记-复制  
3、标记-整理  
＊垃圾回收器  
CMS、G1 


### 反射
随时可以动态地获得类的对象和属性，  
获取Class对象，有四种方法：  
1、Class.forName("类的路径")  
2、类名.class  
3、对象名.getClass()  
4、基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象  




# 数据库
事务的特性：原子性，一致性，隔离性，持久性  
一致性：事务完成后，各部分的数据符合一致性逻辑；(由其他三个特性共同保持的)  
隔离性：多个事务进行，互不干扰；(锁+MVCC)  
原子性：事务的操作是一个整体；(undolog) (记录的数据的历史版本)  
持久性：当发生故障时，确保已提交的事务不受影响－＞（redolog）  
##实现原理
日志有三个：undolog+redolog是innodb基于mysql存储引擎，binlog是mysql自带的日志  

## 两阶段提交
执行器从引擎中找到数据，如果在内存中直接返回，不然从磁盘中读到内存中，更改数据。  
先写redolog(物理日志)，写完置为prepare状态，后写binlog(逻辑日志)，写完之后将redolog置为commited状态。  


## MVCC---解决并发场景下的读写问题
 MVCC实现机制原理三部分：隐藏字段，undolog,readview  
 隐藏字段有三个：DB_TRX_ID（当前事务ID）, DB_ROLL_PTR(上一个历史记录的地址), DB_ROW_ID(主角ID)  
 最终undolog会形成一个链表，链首是最新的数据，链尾是最早的旧纪录。  
readview: 事务在进行快照的时候生成的读视图，并不是存储实际的数据，而是对事务ID的一个记录。  
有三个属性值：trx_list---->readview生成时刻的活跃事务id列表；  
up_limit_id----->列表中最小的事务ID；  
low_limit_id----->即将分配的下一个事务id  
读已提交和可重复读的隔离级别：进行快照生成的readview时机不同   
RC:每次进行快照读都会重新生成readview  
RR：当前事务第一次进行快照读的时候生成的readview，之后都会延续使用。这样根据可见性算法进行判断的时候
会得到不同的结果。


## 事务隔离级别：  
读未提交:一个事务会读取另一个事务还没有提交的数据。  
读已提交：一个事务读取数据，当另一个事务更改数据并提交了以后，先前事务读取的数据变了，造成了不可重复读的现象；  
重复读：  
序列化(脏读，重复读，幻读)  

(read committed)

## redis的底层数据实现
Hash什么时候rehash和
底层怎么实现的？

MYSQL怎么在可重复读的条件下解决了幻读的问题，是通过行锁和间隙锁的组合Next-Key实现的。
https://zhuanlan.zhihu.com/p/27790194


## Mysql
redo日志是InnoDB独有的，它让Mysql拥有了崩溃恢复的能力；  
为什么不是直接对数据也进行  
主键索引---叶子结点存储的都是整条记录  
非主键索引：叶子结点存储的主键ID，  
回表：基于非主键索引的查询，需要多扫描一颗索引树，通过索引拿到数据行id，  
## B树和B+树的区别


# 算法与数据结构
ArrayList是List新的实现接口，线程不安全，Vector是List老的实现类线程安全
初始化为长度0,添加第一个元素时，扩容至10
arrayList扩容每次扩大1.5倍，


Hashmap扩容时，当链表长度大于8，首先判断数组长度，如果小于64，先对数组进行扩容
对key做hash
容量指的是键值对总数
什么时候扩容，达到容量的0.75
put操作的时候，1.7采用头插法
1.8采用的是尾插法
concurrenthashmap通常初始化为16，可以理解为支持的并发数位16，每个segment类似于一个hashmap




二叉树的最近公共祖先；
二叉树的非递归遍历；
最长的递增子序列；


## 场景题
蓄水池抽样问题

